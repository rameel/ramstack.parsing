//----------------------------------------------------------------------------//
// <auto-generated>                                                           //
//     This code was generated by a tool.                                     //
//                                                                            //
//     Changes to this file may cause incorrect behavior                      //
//     and will be lost if the code is regenerated.                           //
// </auto-generated>                                                          //
//----------------------------------------------------------------------------//

#nullable enable

namespace Ramstack.Parsing;

partial class Parser
{
    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2)> Seq<T1, T2>(Parser<T1> parser1, Parser<T2> parser2) =>
        new SeqParser<T1, T2>(parser1, parser2);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2) =>
        new VoidSeq2Parser(parser1, parser2);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3)> Seq<T1, T2, T3>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3) =>
        new SeqParser<T1, T2, T3>(parser1, parser2, parser3);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3) =>
        new VoidSeq3Parser(parser1, parser2, parser3);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4)> Seq<T1, T2, T3, T4>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4) =>
        new SeqParser<T1, T2, T3, T4>(parser1, parser2, parser3, parser4);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4) =>
        new VoidSeq4Parser(parser1, parser2, parser3, parser4);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4, T5 Value5)> Seq<T1, T2, T3, T4, T5>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5) =>
        new SeqParser<T1, T2, T3, T4, T5>(parser1, parser2, parser3, parser4, parser5);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5) =>
        new VoidSeq5Parser(parser1, parser2, parser3, parser4, parser5);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4, T5 Value5, T6 Value6)> Seq<T1, T2, T3, T4, T5, T6>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6) =>
        new SeqParser<T1, T2, T3, T4, T5, T6>(parser1, parser2, parser3, parser4, parser5, parser6);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6) =>
        new VoidSeq6Parser(parser1, parser2, parser3, parser4, parser5, parser6);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4, T5 Value5, T6 Value6, T7 Value7)> Seq<T1, T2, T3, T4, T5, T6, T7>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7) =>
        new SeqParser<T1, T2, T3, T4, T5, T6, T7>(parser1, parser2, parser3, parser4, parser5, parser6, parser7);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7) =>
        new VoidSeq7Parser(parser1, parser2, parser3, parser4, parser5, parser6, parser7);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <param name="parser8">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4, T5 Value5, T6 Value6, T7 Value7, T8 Value8)> Seq<T1, T2, T3, T4, T5, T6, T7, T8>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7, Parser<T8> parser8) =>
        new SeqParser<T1, T2, T3, T4, T5, T6, T7, T8>(parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <param name="parser8">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7, Parser<Unit> parser8) =>
        new VoidSeq8Parser(parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <param name="parser8">The parser instance.</param>
    /// <param name="parser9">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4, T5 Value5, T6 Value6, T7 Value7, T8 Value8, T9 Value9)> Seq<T1, T2, T3, T4, T5, T6, T7, T8, T9>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7, Parser<T8> parser8, Parser<T9> parser9) =>
        new SeqParser<T1, T2, T3, T4, T5, T6, T7, T8, T9>(parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8, parser9);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <param name="parser8">The parser instance.</param>
    /// <param name="parser9">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7, Parser<Unit> parser8, Parser<Unit> parser9) =>
        new VoidSeq9Parser(parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8, parser9);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <param name="parser8">The parser instance.</param>
    /// <param name="parser9">The parser instance.</param>
    /// <param name="parser10">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially and returns a tuple of their results.
    /// </returns>
    public static Parser<(T1 Value1, T2 Value2, T3 Value3, T4 Value4, T5 Value5, T6 Value6, T7 Value7, T8 Value8, T9 Value9, T10 Value10)> Seq<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7, Parser<T8> parser8, Parser<T9> parser9, Parser<T10> parser10) =>
        new SeqParser<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8, parser9, parser10);

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    /// <param name="parser1">The parser instance.</param>
    /// <param name="parser2">The parser instance.</param>
    /// <param name="parser3">The parser instance.</param>
    /// <param name="parser4">The parser instance.</param>
    /// <param name="parser5">The parser instance.</param>
    /// <param name="parser6">The parser instance.</param>
    /// <param name="parser7">The parser instance.</param>
    /// <param name="parser8">The parser instance.</param>
    /// <param name="parser9">The parser instance.</param>
    /// <param name="parser10">The parser instance.</param>
    /// <returns>
    /// A parser that applies the specified parsers sequentially.
    /// </returns>
    public static Parser<Unit> Seq(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7, Parser<Unit> parser8, Parser<Unit> parser9, Parser<Unit> parser10) =>
        new VoidSeq10Parser(parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8, parser9, parser10);

    #region Inner type: SeqParser<T1, T2>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2> : Parser<(T1, T2)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2)
        {
            _parser1 = parser1;
            _parser2 = parser2;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq2Parser(_parser1.Void(), _parser2.Void());
    }

    #endregion

    #region Inner type: VoidSeq2Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq2Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq2Parser"/> class.
        /// </summary>
        public VoidSeq2Parser(Parser<Unit> parser1, Parser<Unit> parser2)
        {
            _parser1 = parser1;
            _parser2 = parser2;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3> : Parser<(T1, T2, T3)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq3Parser(_parser1.Void(), _parser2.Void(), _parser3.Void());
    }

    #endregion

    #region Inner type: VoidSeq3Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq3Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq3Parser"/> class.
        /// </summary>
        public VoidSeq3Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4> : Parser<(T1, T2, T3, T4)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq4Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void());
    }

    #endregion

    #region Inner type: VoidSeq4Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq4Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq4Parser"/> class.
        /// </summary>
        public VoidSeq4Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4, T5>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4, T5> : Parser<(T1, T2, T3, T4, T5)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;
        private readonly Parser<T5> _parser5;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4,T5}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4, T5) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
                && _parser5.TryParse(ref context, out value.Item5!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq5Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void(), _parser5.Void());
    }

    #endregion

    #region Inner type: VoidSeq5Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq5Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;
        private readonly Parser<Unit> _parser5;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq5Parser"/> class.
        /// </summary>
        public VoidSeq5Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
                && _parser5.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4, T5, T6>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4, T5, T6> : Parser<(T1, T2, T3, T4, T5, T6)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;
        private readonly Parser<T5> _parser5;
        private readonly Parser<T6> _parser6;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4,T5,T6}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4, T5, T6) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
                && _parser5.TryParse(ref context, out value.Item5!)
                && _parser6.TryParse(ref context, out value.Item6!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq6Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void(), _parser5.Void(), _parser6.Void());
    }

    #endregion

    #region Inner type: VoidSeq6Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq6Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;
        private readonly Parser<Unit> _parser5;
        private readonly Parser<Unit> _parser6;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq6Parser"/> class.
        /// </summary>
        public VoidSeq6Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
                && _parser5.TryParse(ref context, out value)
                && _parser6.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4, T5, T6, T7>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4, T5, T6, T7> : Parser<(T1, T2, T3, T4, T5, T6, T7)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;
        private readonly Parser<T5> _parser5;
        private readonly Parser<T6> _parser6;
        private readonly Parser<T7> _parser7;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4,T5,T6,T7}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4, T5, T6, T7) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
                && _parser5.TryParse(ref context, out value.Item5!)
                && _parser6.TryParse(ref context, out value.Item6!)
                && _parser7.TryParse(ref context, out value.Item7!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq7Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void(), _parser5.Void(), _parser6.Void(), _parser7.Void());
    }

    #endregion

    #region Inner type: VoidSeq7Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq7Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;
        private readonly Parser<Unit> _parser5;
        private readonly Parser<Unit> _parser6;
        private readonly Parser<Unit> _parser7;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq7Parser"/> class.
        /// </summary>
        public VoidSeq7Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
                && _parser5.TryParse(ref context, out value)
                && _parser6.TryParse(ref context, out value)
                && _parser7.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4, T5, T6, T7, T8>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4, T5, T6, T7, T8> : Parser<(T1, T2, T3, T4, T5, T6, T7, T8)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;
        private readonly Parser<T5> _parser5;
        private readonly Parser<T6> _parser6;
        private readonly Parser<T7> _parser7;
        private readonly Parser<T8> _parser8;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4,T5,T6,T7,T8}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7, Parser<T8> parser8)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
            _parser8 = parser8;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4, T5, T6, T7, T8) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
                && _parser5.TryParse(ref context, out value.Item5!)
                && _parser6.TryParse(ref context, out value.Item6!)
                && _parser7.TryParse(ref context, out value.Item7!)
                && _parser8.TryParse(ref context, out value.Item8!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq8Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void(), _parser5.Void(), _parser6.Void(), _parser7.Void(), _parser8.Void());
    }

    #endregion

    #region Inner type: VoidSeq8Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq8Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;
        private readonly Parser<Unit> _parser5;
        private readonly Parser<Unit> _parser6;
        private readonly Parser<Unit> _parser7;
        private readonly Parser<Unit> _parser8;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq8Parser"/> class.
        /// </summary>
        public VoidSeq8Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7, Parser<Unit> parser8)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
            _parser8 = parser8;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
                && _parser5.TryParse(ref context, out value)
                && _parser6.TryParse(ref context, out value)
                && _parser7.TryParse(ref context, out value)
                && _parser8.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4, T5, T6, T7, T8, T9>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4, T5, T6, T7, T8, T9> : Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;
        private readonly Parser<T5> _parser5;
        private readonly Parser<T6> _parser6;
        private readonly Parser<T7> _parser7;
        private readonly Parser<T8> _parser8;
        private readonly Parser<T9> _parser9;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4,T5,T6,T7,T8,T9}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7, Parser<T8> parser8, Parser<T9> parser9)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
            _parser8 = parser8;
            _parser9 = parser9;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4, T5, T6, T7, T8, T9) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
                && _parser5.TryParse(ref context, out value.Item5!)
                && _parser6.TryParse(ref context, out value.Item6!)
                && _parser7.TryParse(ref context, out value.Item7!)
                && _parser8.TryParse(ref context, out value.Item8!)
                && _parser9.TryParse(ref context, out value.Item9!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq9Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void(), _parser5.Void(), _parser6.Void(), _parser7.Void(), _parser8.Void(), _parser9.Void());
    }

    #endregion

    #region Inner type: VoidSeq9Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq9Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;
        private readonly Parser<Unit> _parser5;
        private readonly Parser<Unit> _parser6;
        private readonly Parser<Unit> _parser7;
        private readonly Parser<Unit> _parser8;
        private readonly Parser<Unit> _parser9;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq9Parser"/> class.
        /// </summary>
        public VoidSeq9Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7, Parser<Unit> parser8, Parser<Unit> parser9)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
            _parser8 = parser8;
            _parser9 = parser9;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
                && _parser5.TryParse(ref context, out value)
                && _parser6.TryParse(ref context, out value)
                && _parser7.TryParse(ref context, out value)
                && _parser8.TryParse(ref context, out value)
                && _parser9.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion

    #region Inner type: SeqParser<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>

    /// <summary>
    /// Represents a parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class SeqParser<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
    {
        private readonly Parser<T1> _parser1;
        private readonly Parser<T2> _parser2;
        private readonly Parser<T3> _parser3;
        private readonly Parser<T4> _parser4;
        private readonly Parser<T5> _parser5;
        private readonly Parser<T6> _parser6;
        private readonly Parser<T7> _parser7;
        private readonly Parser<T8> _parser8;
        private readonly Parser<T9> _parser9;
        private readonly Parser<T10> _parser10;

        /// <summary>
        /// Initializes a new instance of the <see cref="SeqParser{T1,T2,T3,T4,T5,T6,T7,T8,T9,T10}"/> class.
        /// </summary>
        public SeqParser(Parser<T1> parser1, Parser<T2> parser2, Parser<T3> parser3, Parser<T4> parser4, Parser<T5> parser5, Parser<T6> parser6, Parser<T7> parser7, Parser<T8> parser8, Parser<T9> parser9, Parser<T10> parser10)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
            _parser8 = parser8;
            _parser9 = parser9;
            _parser10 = parser10;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value.Item1!)
                && _parser2.TryParse(ref context, out value.Item2!)
                && _parser3.TryParse(ref context, out value.Item3!)
                && _parser4.TryParse(ref context, out value.Item4!)
                && _parser5.TryParse(ref context, out value.Item5!)
                && _parser6.TryParse(ref context, out value.Item6!)
                && _parser7.TryParse(ref context, out value.Item7!)
                && _parser8.TryParse(ref context, out value.Item8!)
                && _parser9.TryParse(ref context, out value.Item9!)
                && _parser10.TryParse(ref context, out value.Item10!)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            new VoidSeq10Parser(_parser1.Void(), _parser2.Void(), _parser3.Void(), _parser4.Void(), _parser5.Void(), _parser6.Void(), _parser7.Void(), _parser8.Void(), _parser9.Void(), _parser10.Void());
    }

    #endregion

    #region Inner type: VoidSeq10Parser

    /// <summary>
    /// Represents a specialized parser that applies the specified parsers sequentially that succeeds only when all parsers succeed.
    /// </summary>
    private sealed class VoidSeq10Parser : Parser<Unit>
    {
        private readonly Parser<Unit> _parser1;
        private readonly Parser<Unit> _parser2;
        private readonly Parser<Unit> _parser3;
        private readonly Parser<Unit> _parser4;
        private readonly Parser<Unit> _parser5;
        private readonly Parser<Unit> _parser6;
        private readonly Parser<Unit> _parser7;
        private readonly Parser<Unit> _parser8;
        private readonly Parser<Unit> _parser9;
        private readonly Parser<Unit> _parser10;

        /// <summary>
        /// Initializes a new instance of the <see cref="VoidSeq10Parser"/> class.
        /// </summary>
        public VoidSeq10Parser(Parser<Unit> parser1, Parser<Unit> parser2, Parser<Unit> parser3, Parser<Unit> parser4, Parser<Unit> parser5, Parser<Unit> parser6, Parser<Unit> parser7, Parser<Unit> parser8, Parser<Unit> parser9, Parser<Unit> parser10)
        {
            _parser1 = parser1;
            _parser2 = parser2;
            _parser3 = parser3;
            _parser4 = parser4;
            _parser5 = parser5;
            _parser6 = parser6;
            _parser7 = parser7;
            _parser8 = parser8;
            _parser9 = parser9;
            _parser10 = parser10;
        }

        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, out Unit value)
        {
            var bookmark = context.BookmarkPosition();

            if (_parser1.TryParse(ref context, out value)
                && _parser2.TryParse(ref context, out value)
                && _parser3.TryParse(ref context, out value)
                && _parser4.TryParse(ref context, out value)
                && _parser5.TryParse(ref context, out value)
                && _parser6.TryParse(ref context, out value)
                && _parser7.TryParse(ref context, out value)
                && _parser8.TryParse(ref context, out value)
                && _parser9.TryParse(ref context, out value)
                && _parser10.TryParse(ref context, out value)
            )
            {
                context.SetMatched(bookmark);
                return true;
            }

            context.RestorePosition(bookmark);
            return false;
        }
    }

    #endregion
}
