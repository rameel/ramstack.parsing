<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="Properties\Autogenerated.ttinclude" #>
#nullable enable

namespace Ramstack.Parsing;

partial class Parser
{
<#
    for (var n = 2; n <= 10; n++)
    {
        WriteSeparatorLine(n != 2);
        GenerateMethods(n);
    }

    for (var n = 2; n <= 10; n++)
    {
        WriteLine();
        GenerateClasses(n);
    }
#>
}
<#+ private void GenerateMethods(int arity) { #>
    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>(this Parser<T> parser, Parser<(<#=GenerateList(arity, n => $"T{n}", from: 1)#>)> item, Func<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>, T> reduce) =>
        new Fold<#=arity#>Parser<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>(this Parser<T> parser, Parser<(<#=GenerateList(arity, n => $"T{n}", from: 1)#>)> item, Func<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>, T> reduce) =>
        new FoldR<#=arity#>Parser<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>(parser, item, reduce);
<#+ } #>
<#+ private void GenerateClasses(int arity) { #>
    #region Inner type: Fold<#=arity#>Parser<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold<#=arity#>Parser<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>(Parser<T> parser, Parser<(<#=GenerateList(arity, n => $"T{n}", from: 1)#>)> item, Func<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            var bookmark = context.BookmarkPosition();

            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, <#=GenerateList(arity, n => $"r.Item{n}", from: 1)#>);

                context.SetMatched(bookmark);
                value = result!;

                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR<#=arity#>Parser<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR<#=arity#>Parser<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>>(Parser<T> parser, Parser<(<#=GenerateList(arity, n => $"T{n}", from: 1)#>)> item, Func<T, <#=GenerateList(arity, n => $"T{n}", from: 1)#>, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            var bookmark = context.BookmarkPosition();

            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(<#=GenerateList(arity, n => $"T{n}", from: 1)#>)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, <#=GenerateList(arity, n => $"r.Item{n}", from: 1)#>);
                }

                context.SetMatched(bookmark);
                value = result!;

                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion
<#+ } #>
