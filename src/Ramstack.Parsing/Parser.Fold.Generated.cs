//----------------------------------------------------------------------------//
// <auto-generated>                                                           //
//     This code was generated by a tool.                                     //
//                                                                            //
//     Changes to this file may cause incorrect behavior                      //
//     and will be lost if the code is regenerated.                           //
// </auto-generated>                                                          //
//----------------------------------------------------------------------------//

#nullable enable

namespace Ramstack.Parsing;

partial class Parser
{
    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2>(this Parser<T> parser, Parser<(T1, T2)> item, Func<T, T1, T2, T> reduce) =>
        new Fold2Parser<T, T1, T2>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2>(this Parser<T> parser, Parser<(T1, T2)> item, Func<T, T1, T2, T> reduce) =>
        new FoldR2Parser<T, T1, T2>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3>(this Parser<T> parser, Parser<(T1, T2, T3)> item, Func<T, T1, T2, T3, T> reduce) =>
        new Fold3Parser<T, T1, T2, T3>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3>(this Parser<T> parser, Parser<(T1, T2, T3)> item, Func<T, T1, T2, T3, T> reduce) =>
        new FoldR3Parser<T, T1, T2, T3>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4>(this Parser<T> parser, Parser<(T1, T2, T3, T4)> item, Func<T, T1, T2, T3, T4, T> reduce) =>
        new Fold4Parser<T, T1, T2, T3, T4>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4>(this Parser<T> parser, Parser<(T1, T2, T3, T4)> item, Func<T, T1, T2, T3, T4, T> reduce) =>
        new FoldR4Parser<T, T1, T2, T3, T4>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4, T5>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5)> item, Func<T, T1, T2, T3, T4, T5, T> reduce) =>
        new Fold5Parser<T, T1, T2, T3, T4, T5>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4, T5>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5)> item, Func<T, T1, T2, T3, T4, T5, T> reduce) =>
        new FoldR5Parser<T, T1, T2, T3, T4, T5>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4, T5, T6>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6)> item, Func<T, T1, T2, T3, T4, T5, T6, T> reduce) =>
        new Fold6Parser<T, T1, T2, T3, T4, T5, T6>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4, T5, T6>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6)> item, Func<T, T1, T2, T3, T4, T5, T6, T> reduce) =>
        new FoldR6Parser<T, T1, T2, T3, T4, T5, T6>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4, T5, T6, T7>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T> reduce) =>
        new Fold7Parser<T, T1, T2, T3, T4, T5, T6, T7>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4, T5, T6, T7>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T> reduce) =>
        new FoldR7Parser<T, T1, T2, T3, T4, T5, T6, T7>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4, T5, T6, T7, T8>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T> reduce) =>
        new Fold8Parser<T, T1, T2, T3, T4, T5, T6, T7, T8>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4, T5, T6, T7, T8>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T> reduce) =>
        new FoldR8Parser<T, T1, T2, T3, T4, T5, T6, T7, T8>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T> reduce) =>
        new Fold9Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T> reduce) =>
        new FoldR9Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>(parser, item, reduce);

    /// <summary>
    /// Creates a left-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number ([+-] Number)*
    /// var sum = number.Fold(
    ///     Seq(OneOf("+-"), number),
    ///     (r, op, d) => op == '+' ? r + n : r - n);
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs left-associative folding over parsed values.
    /// </returns>
    public static Parser<T> Fold<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T> reduce) =>
        new Fold10Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(parser, item, reduce);

    /// <summary>
    /// Creates a right-associative parser that applies the <paramref name="reduce"/> function
    /// to reduce values from the parsed items.
    /// </summary>
    /// <remarks>
    /// <code>
    /// // Number (^ Number)*
    /// var power = number.FoldR(
    ///     Seq(L('^'), number),
    ///     (r, _, d) => Math.Pow(r, d));
    /// </code>
    /// </remarks>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    /// <returns>
    /// A parser that performs right-associative folding over parsed values.
    /// </returns>
    public static Parser<T> FoldR<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T> reduce) =>
        new FoldR10Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(parser, item, reduce);

    #region Inner type: Fold2Parser<T, T1, T2>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold2Parser<T, T1, T2>(Parser<T> parser, Parser<(T1, T2)> item, Func<T, T1, T2, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR2Parser<T, T1, T2>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR2Parser<T, T1, T2>(Parser<T> parser, Parser<(T1, T2)> item, Func<T, T1, T2, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold3Parser<T, T1, T2, T3>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold3Parser<T, T1, T2, T3>(Parser<T> parser, Parser<(T1, T2, T3)> item, Func<T, T1, T2, T3, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR3Parser<T, T1, T2, T3>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR3Parser<T, T1, T2, T3>(Parser<T> parser, Parser<(T1, T2, T3)> item, Func<T, T1, T2, T3, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold4Parser<T, T1, T2, T3, T4>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold4Parser<T, T1, T2, T3, T4>(Parser<T> parser, Parser<(T1, T2, T3, T4)> item, Func<T, T1, T2, T3, T4, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR4Parser<T, T1, T2, T3, T4>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR4Parser<T, T1, T2, T3, T4>(Parser<T> parser, Parser<(T1, T2, T3, T4)> item, Func<T, T1, T2, T3, T4, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold5Parser<T, T1, T2, T3, T4, T5>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold5Parser<T, T1, T2, T3, T4, T5>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5)> item, Func<T, T1, T2, T3, T4, T5, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR5Parser<T, T1, T2, T3, T4, T5>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR5Parser<T, T1, T2, T3, T4, T5>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5)> item, Func<T, T1, T2, T3, T4, T5, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4, T5)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold6Parser<T, T1, T2, T3, T4, T5, T6>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold6Parser<T, T1, T2, T3, T4, T5, T6>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6)> item, Func<T, T1, T2, T3, T4, T5, T6, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR6Parser<T, T1, T2, T3, T4, T5, T6>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR6Parser<T, T1, T2, T3, T4, T5, T6>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6)> item, Func<T, T1, T2, T3, T4, T5, T6, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4, T5, T6)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold7Parser<T, T1, T2, T3, T4, T5, T6, T7>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold7Parser<T, T1, T2, T3, T4, T5, T6, T7>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR7Parser<T, T1, T2, T3, T4, T5, T6, T7>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR7Parser<T, T1, T2, T3, T4, T5, T6, T7>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4, T5, T6, T7)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold8Parser<T, T1, T2, T3, T4, T5, T6, T7, T8>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold8Parser<T, T1, T2, T3, T4, T5, T6, T7, T8>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7, r.Item8);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR8Parser<T, T1, T2, T3, T4, T5, T6, T7, T8>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR8Parser<T, T1, T2, T3, T4, T5, T6, T7, T8>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4, T5, T6, T7, T8)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7, r.Item8);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold9Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold9Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7, r.Item8, r.Item9);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR9Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR9Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4, T5, T6, T7, T8, T9)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7, r.Item8, r.Item9);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: Fold10Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>

    /// <summary>
    /// Represents a left-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class Fold10Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                while (item.TryParse(ref context, out var r))
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7, r.Item8, r.Item9, r.Item10);

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion

    #region Inner type: FoldR10Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>

    /// <summary>
    /// Represents a right-associative parser that accumulates parsed items using a specified reduction function.
    /// </summary>
    /// <param name="parser">The initial parser.</param>
    /// <param name="item">The parser for values to accumulate.</param>
    /// <param name="reduce">A reduction function.</param>
    private sealed class FoldR10Parser<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(Parser<T> parser, Parser<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)> item, Func<T, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T> reduce) : Parser<T>
    {
        /// <inheritdoc />
        public override bool TryParse(ref ParseContext context, [NotNullWhen(true)] out T? value)
        {
            if (parser.TryParse(ref context, out var result))
            {
                var values = new ArrayList<(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>();
                while (item.TryParse(ref context, out var v))
                    values.Add(v);

                for (var i = values.Count - 1; i >= 0; i--)
                {
                    ref var r = ref values[i];
                    result = reduce(result, r.Item1, r.Item2, r.Item3, r.Item4, r.Item5, r.Item6, r.Item7, r.Item8, r.Item9, r.Item10);
                }

                value = result!;
                return true;
            }

            value = default;
            return false;
        }

        /// <inheritdoc />
        protected internal override Parser<Unit> ToVoidParser() =>
            Seq(parser.Void(), item.Void().ZeroOrMore());
    }

    #endregion
}
